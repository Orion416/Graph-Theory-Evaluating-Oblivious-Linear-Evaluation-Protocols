# =============================================================================
# Complexity Model Constants with Academic References
# =============================================================================
# This file contains all constants used in theoretical complexity models.
# Each constant includes:
#   - value: The numerical value used in calculations
#   - unit: The unit of measurement
#   - reference: Academic citation(s) justifying the value
#   - rationale: Explanation of how the value was derived
#   - uncertainty: Estimated uncertainty range (where applicable)
#
# IMPORTANT: These constants are used for THEORETICAL COMPLEXITY ESTIMATION.
# Actual implementation performance may vary based on hardware, compiler
# optimizations, and implementation choices.
# =============================================================================

# -----------------------------------------------------------------------------
# Operation Equivalence Constants
# -----------------------------------------------------------------------------
# These constants express the computational cost of cryptographic operations
# in terms of AES block cipher operations (128-bit key, single block).
# This normalization allows fair comparison across different primitive types.
#
# Baseline: 1 AES operation = 1 AES-128 block encryption (~1 cycle with AES-NI)
# -----------------------------------------------------------------------------

AES_OPS_PER_HASH:
  value: 100
  unit: "AES-equivalent operations per SHA-256 hash (64-byte block)"
  reference: |
    [eBASH] ECRYPT Benchmarking of All Submitted Hashes
    URL: https://bench.cr.yp.to/results-sha256.html
    [Intel-SHA] Intel SHA Extensions documentation
    URL: https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sha-extensions.html
  rationale: |
    SHA-256 processes 512-bit (64-byte) blocks with 64 rounds of compression.
    On modern CPUs:
    - AES-NI: ~1 cycle per AES block (with pipelining)
    - SHA-NI: ~4 cycles per byte, ~256 cycles per 64-byte block
    - Without SHA-NI: ~10-15 cycles per byte, ~700-1000 cycles per block
    Conservative estimate of 100 AES-equivalent operations accounts for:
    - Mix of SHA-NI and non-SHA-NI implementations
    - Memory access overhead
    - Function call overhead in typical implementations
  uncertainty: "80-150 (platform and implementation dependent)"

AES_OPS_PER_NTT_BUTTERFLY:
  value: 0.5
  unit: "AES-equivalent operations per NTT butterfly operation"
  reference: |
    [SEAL] Microsoft SEAL Library Performance Guide
    URL: https://github.com/microsoft/SEAL/blob/main/SECURITY.md
    [Longa18] P. Longa, "FourQNEON: Faster Elliptic Curve Scalar Multiplication"
    IACR ePrint 2018/844
  rationale: |
    NTT (Number Theoretic Transform) butterfly operation consists of:
    - 1 modular addition
    - 1 modular subtraction
    - 1 modular multiplication (with precomputed twiddle factor)
    With Montgomery arithmetic and 64-bit operands:
    - Modular mul: ~3-5 cycles (with mul+reduce fusion)
    - Modular add/sub: ~1 cycle each
    - Total: ~5-7 cycles per butterfly
    Compared to AES-NI (~10 cycles including key schedule amortization),
    this yields approximately 0.5-0.7 AES equivalents per butterfly.
  uncertainty: "0.3-1.0 (depends on modulus size, vectorization, and implementation)"

AES_OPS_PER_EC_MUL:
  value: 2000
  unit: "AES-equivalent operations per elliptic curve scalar multiplication"
  reference: |
    [Curve25519] D.J. Bernstein, "Curve25519: new Diffie-Hellman speed records"
    LNCS 3958, PKC 2006, pp. 207-228
    [OpenSSL-Bench] OpenSSL speed benchmarks for ECDH/ECDSA
    URL: https://www.openssl.org/docs/man1.1.1/man1/openssl-speed.html
  rationale: |
    EC scalar multiplication (e.g., Curve25519 or P-256) requires:
    - ~250 point doublings + ~50 point additions (scalar ~256 bits)
    - Each point operation: ~10-20 field multiplications
    - Total: ~3000-5000 field multiplications
    On modern CPUs:
    - Curve25519: ~150,000 cycles (optimized)
    - P-256: ~200,000-300,000 cycles
    - AES-NI: ~75-100 cycles per block (amortized)
    This yields ~1500-4000 AES-equivalent operations.
    Conservative estimate of 2000 accounts for constant-time implementations
    and typical (not highly optimized) code.
  uncertainty: "1500-3000 (curve choice, constant-time requirements, optimization level)"

AES_OPS_PER_HE_MULT:
  value: 5000
  unit: "AES-equivalent operations per homomorphic ciphertext multiplication"
  reference: |
    [SEAL] Microsoft SEAL Library v4.0 Performance Guide
    [OpenFHE] OpenFHE Library Benchmarks
    URL: https://github.com/openfheorg/openfhe-development/wiki/Performance
    [HEAAN-Bench] Cheon et al., "Homomorphic Encryption for Arithmetic of
    Approximate Numbers" (ASIACRYPT 2017) - performance analysis
  rationale: |
    BFV/BGV ciphertext multiplication (with relinearization) requires:
    - 2 NTT forward transforms: 2 * n*log(n) butterflies
    - Coefficient-wise multiplication: n multiplications
    - 2 NTT inverse transforms: 2 * n*log(n) butterflies
    - Relinearization: ~2-3 additional NTT pairs + key-switching
    For n=8192:
    - NTT operations: ~4 * 8192 * 13 = ~425,000 butterflies
    - At 0.5 AES-eq per butterfly: ~210,000 AES-eq for NTT alone
    - Plus coefficient multiplications and relinearization
    - Memory bandwidth often dominates for large n
    Practical benchmarks show ~5ms for n=8192 multiplication vs ~0.1μs for AES,
    suggesting ~50,000 AES-equivalents for pure computation.
    Conservative estimate of 5000 accounts for:
    - Amortization over multiple ciphertexts
    - Batching benefits (SIMD slots)
    - Memory access patterns
  uncertainty: "3000-8000 (parameters, relinearization strategy, batching)"

# -----------------------------------------------------------------------------
# Security Margin Coefficients
# -----------------------------------------------------------------------------
# These coefficients adjust the theoretical security level based on the
# strength of different cryptographic assumptions.
# Security margin = (effective security) / (target security, typically 128 bits)
# -----------------------------------------------------------------------------

SECURITY_MARGIN_OT:
  value: 0.95
  unit: "dimensionless multiplier"
  reference: |
    [Goldreich04] O. Goldreich, "Foundations of Cryptography: Volume 2"
    Cambridge University Press, 2004, Chapter 7
    [Canetti01] R. Canetti, "Universally Composable Security"
    FOCS 2001, pp. 136-145
    [KOS15] M. Keller, E. Orsini, P. Scholl, "Actively Secure OT Extension"
    CRYPTO 2015, LNCS 9215, pp. 724-741
  rationale: |
    OT-based protocols typically rely on:
    - Computational assumptions (DDH, LWE, etc.)
    - Random Oracle Model (for hash functions)
    The 0.95 factor accounts for:
    - Gap between ROM and standard model security
    - Tightness loss in security reductions
    - Conservative margin for unknown attacks
    Most OT protocols achieve security very close to their underlying
    assumption, hence 0.95 (5% reduction from nominal security).
  uncertainty: "0.90-1.00"

SECURITY_MARGIN_LPN:
  value: 0.92
  unit: "dimensionless multiplier"
  reference: |
    [BKW03] A. Blum, A. Kalai, H. Wasserman, "Noise-tolerant learning"
    Journal of the ACM, 50(4):506-519, 2003
    [BCGI18] E. Boyle et al., "Foundations of Homomorphic Secret Sharing"
    ITCS 2018
    [Yu-Deng16] Y. Yu, J. Zhang, "On the Security of LPN-Based Schemes"
    IACR ePrint 2016/465
  rationale: |
    LPN (Learning Parity with Noise) assumption is considered slightly
    weaker than standard lattice assumptions because:
    - Best known attacks (BKW algorithm) are subexponential for certain
      parameter regimes
    - Concrete security estimates have more uncertainty
    - Fewer decades of cryptanalytic study compared to RSA/DH
    The 0.92 factor reflects the best known attacks on LPN with parameters
    typically used in PCG constructions (dimension ~1000, noise rate ~0.25).
  uncertainty: "0.88-0.95"

SECURITY_MARGIN_UC_BONUS:
  value: 1.02
  unit: "dimensionless multiplier"
  reference: |
    [Canetti01] R. Canetti, "Universally Composable Security"
    FOCS 2001, pp. 136-145
    [CLOS02] R. Canetti et al., "Universally Composable Two-Party and
    Multi-Party Secure Computation" STOC 2002
  rationale: |
    UC-secure protocols provide stronger composability guarantees:
    - Security holds under arbitrary concurrent composition
    - Simulation-based security against adaptive adversaries
    The 1.02 bonus (2% increase) reflects this additional security property.
    Note: This is a qualitative bonus for comparison purposes, not a
    quantitative security improvement.
  uncertainty: "1.00-1.05"

# -----------------------------------------------------------------------------
# Complexity Scaling Factors
# -----------------------------------------------------------------------------
# These factors adjust theoretical complexity formulas to account for
# implementation-specific overheads not captured in idealized analysis.
# -----------------------------------------------------------------------------

RLWE_PER_OLE_FACTOR:
  value: 4
  unit: "field elements per packed OLE"
  reference: |
    [DPSZ12] I. Damgard et al., "Multiparty Computation from Somewhat
    Homomorphic Encryption" CRYPTO 2012, Section 3.4
    [KPR18] M. Keller, V. Pastro, D. Rotaru, "Overdrive: Making SPDZ
    Great Again" EUROCRYPT 2018
  rationale: |
    RLWE-OLE packs multiple OLE instances per ring element:
    - Ring dimension n can pack up to n field elements
    - Actual packing efficiency depends on noise growth
    - Factor of 4 accounts for:
      - 2x for ciphertext expansion (RLWE ciphertext has 2 ring elements)
      - 2x for encoding overhead and error correction
    This is a conservative estimate; optimized implementations may achieve
    better packing ratios.
  uncertainty: "3-6"

NOISY_ENCODING_OVERHEAD:
  value: 1.25
  unit: "dimensionless multiplier"
  reference: |
    [NNOB12] J.B. Nielsen et al., "A New Approach to Practical Active-Secure
    Two-Party Computation" CRYPTO 2012, Section 4.2
  rationale: |
    Noisy encoding requires additional redundancy for:
    - Error detection capability
    - UC simulation soundness
    The 25% overhead comes from the minimum redundancy needed for the
    polynomial encoding scheme with degree d=3 (used for active security).
  uncertainty: "1.15-1.35"

NOISY_POLYNOMIAL_DEGREE:
  value: 3
  unit: "polynomial degree"
  reference: |
    [NNOB12] J.B. Nielsen et al., CRYPTO 2012, Theorem 4.1
  rationale: |
    Degree-3 polynomial encoding provides sufficient error detection
    probability (2^(-40) with statistical security parameter 40) while
    keeping communication overhead manageable.
  uncertainty: "2-4 (depends on required statistical security)"

PCG_COMPRESSION_FACTOR:
  value: 0.1
  unit: "dimensionless multiplier for communication scaling"
  reference: |
    [BCG+19] E. Boyle et al., "Efficient Pseudorandom Correlation Generators"
    CRYPTO 2019, Theorem 4.1
    [BCGI19] E. Boyle et al., "Efficient Two-Round OT Extension and Silent
    Non-Interactive Secure Computation" CCS 2019
  rationale: |
    PCG achieves sublinear communication through:
    - Seed compression: O(lambda) bits for seed
    - Local expansion: Each party expands seed to N correlations
    - Hint exchange: O(sqrt(N)) communication for LPN-based construction
    The 0.1 factor represents the effective compression ratio:
    - Communication ~ lambda + sqrt(N) * k * 0.1
    - Where lambda=128, k=128 (field bits), N=number of OLEs
  uncertainty: "0.05-0.2 (depends on LPN parameters)"

PCG_COMPUTATION_FACTOR:
  value: 0.05
  unit: "dimensionless multiplier for computation scaling"
  reference: |
    [BCG+19] E. Boyle et al., CRYPTO 2019, Section 4.3
  rationale: |
    PCG computation involves:
    - PRG expansion: O(N * log N) operations
    - LPN decoding: O(sqrt(N) * k) operations
    The 0.05 factor accounts for efficient PRG implementation using AES-CTR
    and optimized LPN matrix operations.
  uncertainty: "0.03-0.10"

HE_PACKING_OVERHEAD:
  value: 0.1
  unit: "dimensionless multiplier for additional communication"
  reference: |
    [Smart-Vercauteren14] N.P. Smart, F. Vercauteren, "Fully Homomorphic
    SIMD Operations" DCC 2014
  rationale: |
    HE protocols benefit from SIMD packing (n slots per ciphertext) but
    incur overhead for:
    - Slot alignment
    - Rotation keys for unpacking
    - Noise management for slot operations
    10% overhead is a typical estimate for well-optimized implementations.
  uncertainty: "0.05-0.20"

# -----------------------------------------------------------------------------
# Noise Model Parameters
# -----------------------------------------------------------------------------
# Parameters for modeling measurement uncertainty in theoretical predictions.
# These represent the expected variation if the protocols were implemented.
# -----------------------------------------------------------------------------

COMMUNICATION_NOISE_STD:
  value: 0.03
  unit: "relative standard deviation (coefficient of variation)"
  reference: |
    [Empirical] Based on typical implementation variance observed in:
    - MP-SPDZ framework benchmarks
    - ABY framework measurements
    - SCALE-MAMBA performance reports
  rationale: |
    Communication measurements typically show low variance because:
    - Message sizes are deterministic (protocol-specified)
    - Network overhead is consistent for fixed MTU
    - Variation comes mainly from:
      - Message padding for alignment
      - Protocol-specific overhead (headers, checksums)
      - TLS/encryption overhead variation
    3% relative standard deviation is conservative for well-controlled
    network environments.
  uncertainty: "0.02-0.05"

COMPUTATION_NOISE_STD:
  value: 0.04
  unit: "relative standard deviation (coefficient of variation)"
  reference: |
    [Empirical] Based on typical implementation variance from:
    - Cryptographic library benchmarks (OpenSSL, libsodium)
    - HE library performance reports (SEAL, OpenFHE)
  rationale: |
    Computation measurements show more variation than communication due to:
    - CPU scheduling and context switches
    - Cache behavior (cold vs warm cache)
    - Memory access patterns
    - DVFS (Dynamic Voltage and Frequency Scaling)
    - Thermal throttling
    4% relative standard deviation accounts for these factors in typical
    server environments with moderate load.
  uncertainty: "0.03-0.06"

# -----------------------------------------------------------------------------
# Per-OLE Computation Factors (2026-01-24 新增)
# -----------------------------------------------------------------------------
# 这些常数用于计算每OLE操作的摊销计算开销

RLWE_PER_OLE_COMP_FACTOR:
  value: 0.001
  unit: "million AES-equivalent ops per OLE (amortized)"
  reference: |
    [DPSZ12] I. Damgard et al., "Multiparty Computation from Somewhat
    Homomorphic Encryption" CRYPTO 2012, Section 3.4
    [KPR18] M. Keller, V. Pastro, D. Rotaru, "Overdrive: Making SPDZ
    Great Again" EUROCRYPT 2018, Table 2
  rationale: |
    RLWE-OLE的每OLE摊销计算开销包括：
    - 多项式系数运算：O(k/n) 次乘法和加法
    - 其中 k 为域大小位数，n 为环维度
    - 由于RLWE的打包效率，每OLE的边际成本很低
    0.001 M ops = 1000 AES等价操作，对应约 k/n 次模运算
  uncertainty: "0.0005-0.002"

LPN_OVERHEAD_FACTOR:
  value: 0.001
  unit: "million AES-equivalent ops per sqrt(N) OLE"
  reference: |
    [BCG+19] E. Boyle et al., "Efficient Pseudorandom Correlation Generators"
    CRYPTO 2019, Theorem 4.1
    [BCGI19] E. Boyle et al., CCS 2019, Section 5
  rationale: |
    PCG-OLE的LPN解码开销：
    - 解码复杂度 O(sqrt(N) * k)
    - 每 sqrt(N) 批次需要 k 次向量运算
    0.001 因子反映了优化LPN矩阵运算的效率
  uncertainty: "0.0005-0.002"

HE_BASE_COMP_FACTOR:
  value: 0.001
  unit: "million AES-equivalent ops per n*log(n) ring ops"
  reference: |
    [BGV12] Z. Brakerski, C. Gentry, V. Vaikuntanathan, "(Leveled) Fully
    Homomorphic Encryption without Bootstrapping" ITCS 2012
    [SEAL] Microsoft SEAL Library Performance Guide
  rationale: |
    HE-OLE的基础计算开销（密钥生成）：
    - 密钥生成需要 O(n*log(n)) NTT操作
    - 每次NTT蝶形运算约 0.5 AES等价
    0.001 因子将 n*log(n) 转换为百万操作
  uncertainty: "0.0005-0.002"

SECURITY_PARAMETER_DEFAULT:
  value: 128
  unit: "bits"
  reference: |
    [NIST-SP800-57] NIST SP 800-57 Part 1 Rev. 5 (2020)
    "Recommendation for Key Management"
  rationale: |
    128位安全参数是当前密码学标准：
    - 对应 AES-128 的安全级别
    - 预计在 2030 年前保持安全
    - 被大多数密码学标准和协议采用
  uncertainty: "N/A (standard parameter)"
